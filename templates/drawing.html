<!DOCTYPE html>
<html>
<head>
    <title>Gesture Drawing (No Manual Slider)</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <!-- Include Socket.IO from a CDN -->
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
    
    <!-- Mediapipe (Hands) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
</head>
<body class="light-purple-bg">
    <h1 style="text-align:center;">Gesture Drawing (30s)</h1>
    <div id="timer" class="countdown-timer" style="text-align:center;">Waiting for start...</div>

    <div style="display:flex; justify-content:center; margin-top:20px;">
      <!-- The video on one side (optionally smaller) -->
      <video id="userVideo" autoplay playsinline style="border:1px solid black; width:320px; height:240px; margin-right:50px;"></video>

      <!-- A larger, centered canvas -->
      <canvas id="drawCanvas" width="900" height="600" 
              style="border:3px solid #000; background-color:white;"></canvas>
    </div>

    <script>
    // SocketIO connection
    var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port);

    // Timer / State
    let drawingActive = false; 
    let timerInterval = null;
    let timeLeft = 0;

    socket.on('startDrawing', (data) => {
        // Admin triggered the start
        timeLeft = data.duration; // e.g. 30
        drawingActive = true;
        startTimer();
    });

    socket.on('startVoting', (data) => {
        // If not submitted, submit automatically
        if (drawingActive) {
            endDrawingAndSubmit();
        }
        // Then redirect
        window.location.href = "/voting";
    });

    socket.on('endVoting', () => {
        window.location.href = "/results";
    });

    function startTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
        }
        timerInterval = setInterval(() => {
            if (timeLeft <= 0) {
                clearInterval(timerInterval);
                document.getElementById('timer').innerText = "Time's up!";
                drawingActive = false;
                endDrawingAndSubmit();
                return;
            }
            document.getElementById('timer').innerText = "Time Left: " + timeLeft;
            timeLeft -= 1;
        }, 1000);
    }

    // Setup video + canvas
    const videoElement = document.getElementById('userVideo');
    const canvasElement = document.getElementById('drawCanvas');
    const canvasCtx = canvasElement.getContext('2d');

    // Start user camera
    navigator.mediaDevices.getUserMedia({video:true})
    .then(stream => {
        videoElement.srcObject = stream;
    })
    .catch(err => {
        console.error("Camera error:", err);
    });

    // Our brush settings
    let brushColor = 'black';
    let brushSize = 5;

    // We'll track previous position for drawing
    let prevX = null, prevY = null;

    // Some help to avoid spamming color/size changes
    let lastGestureChangeTime = 0;
    const GESTURE_COOLDOWN = 1000; // 1 second

    // Mediapipe Hands
    const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
    });
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1
    });

    hands.onResults(onResults);

    const camera = new CameraUtils.Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        }
    });
    camera.start();

    function onResults(results) {
        // If we're not actively drawing, do nothing
        if (!drawingActive) {
            prevX = null;
            prevY = null;
            return;
        }

        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            prevX = null; prevY = null;
            return;
        }
        const landmarks = results.multiHandLandmarks[0];
        // landmarks[i] => x,y,z in [0..1] normalized

        // We'll define some basic gesture logic
        const extendedFingers = detectExtendedFingers(landmarks);
        // extendedFingers is an array of which finger indices are extended (e.g. [0,2] means thumb+middle extended)

        // 1) If only index is extended => we draw
        // 2) If index+middle => cycle color
        // 3) If index+ring => increase brush size
        // 4) If index+pinky => decrease brush size

        if (extendedFingers.includes(1) && extendedFingers.length === 1) {
            // index only => draw
            drawWithIndex(landmarks[8]);
        } else {
            // If not strictly index only, reset
            prevX = null;
            prevY = null;
        }

        let now = new Date().getTime();
        if (now - lastGestureChangeTime > GESTURE_COOLDOWN) {
            // check for color or size changes
            // index=1, middle=2, ring=3, pinky=4
            if (extendedFingers.sort().join(',') === '1,2') {
                cycleColor();
                lastGestureChangeTime = now;
            }
            else if (extendedFingers.sort().join(',') === '1,3') {
                // Increase brush
                brushSize = Math.min(50, brushSize + 2);
                lastGestureChangeTime = now;
            }
            else if (extendedFingers.sort().join(',') === '1,4') {
                // Decrease brush
                brushSize = Math.max(1, brushSize - 2);
                lastGestureChangeTime = now;
            }
        }
    }

    function drawWithIndex(indexTip) {
        const x = indexTip.x * canvasElement.width;
        const y = indexTip.y * canvasElement.height;

        if (prevX == null || prevY == null) {
            prevX = x;
            prevY = y;
        }
        canvasCtx.strokeStyle = brushColor;
        canvasCtx.lineWidth = brushSize;
        canvasCtx.lineCap = 'round';

        canvasCtx.beginPath();
        canvasCtx.moveTo(prevX, prevY);
        canvasCtx.lineTo(x, y);
        canvasCtx.stroke();

        prevX = x;
        prevY = y;
    }

    function cycleColor() {
        // Simple cycle among a set of colors
        const colors = ['black','blue','green','red','yellow','white'];
        let idx = colors.indexOf(brushColor);
        idx = (idx + 1) % colors.length;
        brushColor = colors[idx];
    }

    // detectExtendedFingers => returns array of finger indices that appear extended
    // finger index reference: 0=thumb, 1=index, 2=middle, 3=ring, 4=pinky
    function detectExtendedFingers(landmarks) {
        // A very simplified approach:
        // We can compare TIP .y with PIP .y (in y-coordinates, if tip is < pip => finger extended in upright scenario).
        // But this is a simplistic approach that depends on the hand orientation. 
        // For a more robust approach, measure angles. For brevity, do a simple approach.

        // Landmark indices (for each finger):
        // Thumb: (4 tip, 3 IP, 2 MCP, 1 CMC)
        // Index: (8 tip, 7 DIP, 6 PIP, 5 MCP)
        // Middle: (12 tip, 11 DIP, 10 PIP, 9 MCP)
        // Ring: (16 tip, 15 DIP, 14 PIP, 13 MCP)
        // Pinky: (20 tip, 19 DIP, 18 PIP, 17 MCP)

        let extended = [];

        // We'll define "extended" if tip.y < pip.y (hand palm down scenario).
        // For thumb we might do a different check. 
        // This is a naive approach â€“ for demonstration only.

        // Index finger
        if (landmarks[8].y < landmarks[6].y) {
            extended.push(1);
        }
        // Middle
        if (landmarks[12].y < landmarks[10].y) {
            extended.push(2);
        }
        // Ring
        if (landmarks[16].y < landmarks[14].y) {
            extended.push(3);
        }
        // Pinky
        if (landmarks[20].y < landmarks[18].y) {
            extended.push(4);
        }

        // For the thumb (0)
        // If we want to consider it, we can do a sideways measure or skip. We'll skip for now.

        return extended;
    }

    function endDrawingAndSubmit() {
        drawingActive = false;
        // Convert final canvas to base64
        let canvasData = canvasElement.toDataURL('image/png');

        // Also capture a snapshot from video
        let tempCanvas = document.createElement('canvas');
        tempCanvas.width = videoElement.videoWidth;
        tempCanvas.height = videoElement.videoHeight;
        let tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);
        let webcamData = tempCanvas.toDataURL('image/png');

        // Send to server
        fetch("/submit_drawing", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ canvas: canvasData, webcam: webcamData })
        })
        .then(res => res.json())
        .then(data => {
            console.log("Submitted drawing:", data);
            document.getElementById('timer').innerText = "Submitted. Waiting for voting...";
        })
        .catch(err => console.error(err));
        // Only index extended = draw.
        // Index+Middle extended = change color.
        // Index+Ring extended = increase brush size.
        // Index+Pinky extended = decrease brush size.

    }
    </script>
</body>
</html>

