<!DOCTYPE html>
<html>
<head>
    <title>Gesture Drawing (Simple)</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

    <!-- Socket.IO client -->
    <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>

    <!-- Mediapipe for gesture recognition -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
</head>
<body class="light-purple-bg" style="margin:0; padding:0; text-align:center;">
    <h1 style="margin-top:20px;">Gesture Drawing (30s)</h1>
    <div id="timer" style="text-align:center; font-size:18px;">Waiting for start...</div>

    <div style="display:flex; justify-content:center; margin-top:20px;">
        <!-- Mirrored webcam feed on the left -->
        <video id="userVideo" autoplay playsinline
               style="border:1px solid black; width:320px; height:240px; margin-right:50px; transform: scaleX(-1);">
        </video>

        <!-- White canvas on the right for drawing -->
        <canvas id="drawCanvas" width="900" height="600"
                style="border:3px solid #000; background-color:white;">
        </canvas>
    </div>

    <div style="text-align:center; margin-top:20px;">
        <button onclick="clearCanvas()">Clear Canvas</button>
    </div>

    <script>
    /************************************************************
     * 1) SOCKET.IO - Timer & Submission
     ************************************************************/
    const socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port);

    let drawingActive = false;
    let timeLeft = 0;
    let timerInterval = null;

    socket.on('startDrawing', (data) => {
        timeLeft = data.duration || 30;
        drawingActive = true;
        startTimer();
    });

    socket.on('startVoting', () => {
        if (drawingActive) {
            endDrawingAndSubmit();
        }
        window.location.href = "/voting";
    });

    socket.on('endVoting', () => {
        window.location.href = "/results";
    });

    function startTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            if (timeLeft <= 0) {
                clearInterval(timerInterval);
                document.getElementById('timer').innerText = "Time's up!";
                drawingActive = false;
                endDrawingAndSubmit();
                return;
            }
            document.getElementById('timer').innerText = "Time Left: " + timeLeft;
            timeLeft--;
        }, 1000);
    }

    /************************************************************
     * 2) VIDEO STREAM
     ************************************************************/
    const videoElement = document.getElementById('userVideo');
    navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
            videoElement.srcObject = stream;
        })
        .catch(err => {
            console.error("Camera error:", err);
        });

    /************************************************************
     * 3) CANVAS & DRAWING CONTEXT
     ************************************************************/
    const canvasElement = document.getElementById('drawCanvas');
    const canvasCtx = canvasElement.getContext('2d');
    let brushColor = 'black';
    let brushSize = 5;
    let prevX = null, prevY = null;

    clearCanvas();

    // Initialize Canvas
    function clearCanvas() {
        canvasCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transformations
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.fillStyle = "white";
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        // Flip the canvas horizontally to match the mirrored video
        canvasCtx.translate(canvasElement.width, 0);
        canvasCtx.scale(-1, 1);
        prevX = null;
        prevY = null;
    }


    /************************************************************
     * 4) MEDIAPIPE HANDS
     ************************************************************/
    const hands = new Hands({
        locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({ image: videoElement });
        }
    });
    camera.start();

    /************************************************************
     * 5) On Each Frame - Check if we draw
     ************************************************************/
    function onResults(results) {
        if (!drawingActive || !results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            prevX = null;
            prevY = null;
            return;
        }
        const landmarks = results.multiHandLandmarks[0];
        const extendedFingers = detectExtendedFingers(landmarks);

        if (extendedFingers.includes(1) && extendedFingers.length === 1) {
            drawWithIndex(landmarks[8]);
        } else {
            prevX = null;
            prevY = null;
        }
    }

    function drawWithIndex(indexTip) {
        // Transform the x-coordinate for the flipped canvas
        const x = indexTip.x * canvasElement.width;
        const y = indexTip.y * canvasElement.height;

        if (prevX == null || prevY == null) {
            prevX = x;
            prevY = y;
        }

        // Draw on the flipped canvas
        canvasCtx.strokeStyle = brushColor;
        canvasCtx.lineWidth = brushSize;
        canvasCtx.lineCap = 'round';
        canvasCtx.beginPath();
        canvasCtx.moveTo(prevX, prevY);
        canvasCtx.lineTo(x, y);
        canvasCtx.stroke();

        prevX = x;
        prevY = y;
    }


    function detectExtendedFingers(landmarks) {
        let extended = [];
        if (landmarks[8].y  < landmarks[6].y)  extended.push(1);
        if (landmarks[12].y < landmarks[10].y) extended.push(2);
        if (landmarks[16].y < landmarks[14].y) extended.push(3);
        if (landmarks[20].y < landmarks[18].y) extended.push(4);
        return extended;
    }

    /************************************************************
     * 6) End Drawing & Submit
     ************************************************************/
    function endDrawingAndSubmit() {
        drawingActive = false;

        // 1) Convert final canvas to base64
        const canvasData = canvasElement.toDataURL('image/png');

        // 2) Also capture a snapshot from the mirrored webcam
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = videoElement.videoWidth;
        tempCanvas.height = videoElement.videoHeight;
        const tempCtx = tempCanvas.getContext('2d');

        // Flip context horizontally before drawing video to keep mirror effect
        tempCtx.translate(tempCanvas.width, 0);
        tempCtx.scale(-1, 1);
        tempCtx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);

        const webcamData = tempCanvas.toDataURL('image/png');

        // 3) POST to /submit_drawing
        fetch("/submit_drawing", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ canvas: canvasData, webcam: webcamData })
        })
        .then(res => res.json())
        .then(data => {
            console.log("Submitted drawing:", data);
            document.getElementById('timer').innerText = "Submitted. Waiting...";
        })
        .catch(err => console.error(err));
    }
    </script>
</body>
</html>